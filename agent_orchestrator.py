import argparse
import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from rich.console import Console

console = Console()


load_dotenv()


project_root = Path(__file__).resolve().parent
sys.path.insert(0, str(project_root / 'src'))

from agents.planner_agent import PlannerAgent
from agents.coding_agent import CodingAgent
from agents.packaging_agent import PackagingAgent
from plan_manager import PlanManager
from src.base import CodeAgent


SANDBOX_DIR = project_root / 'sandbox'
INPUT_DIR = SANDBOX_DIR / 'input'
OUTPUT_DIR = SANDBOX_DIR / 'output'
PLAN_FILE = SANDBOX_DIR / 'plan.md'

from utils.context_loader import load_project_context



def run_plan_mode():
    """
    Generates the migration plan.
    1. Loads Angular project context.
    2. Invokes PlannerAgent (simulated LLM call for now).
    3. Writes the plan to plan.md.
    """
    console.print("üöÄ [bold bright_blue]Starting Orchestrator in PLAN mode...[/]")
    angular_context = load_project_context(INPUT_DIR)

    if not angular_context:
        console.print("‚ùå [bold red]Could not load Angular project context. Exiting plan mode.[/]")
        return

    planner = PlannerAgent() 
    console.print("‚ú® [bold blue]Invoking PlannerAgent to generate migration plan...[/]")
    plan_markdown = planner.generate_plan(angular_context, OUTPUT_DIR, INPUT_DIR)
    
    if "Migration Plan Error" in plan_markdown or not plan_markdown.strip():
        console.print("‚ùå [bold red]PlannerAgent returned an error or empty plan. Aborting plan mode.[/]")
        return

    console.print(f"üìù [dim]Plan generated by PlannerAgent:[/]\n[dim]{plan_markdown[:300]}...[/]")

    try:
        with open(PLAN_FILE, 'w', encoding='utf-8') as f:
            f.write(plan_markdown)
        console.print(f"‚úÖ [bold green]Migration plan written to:[/] üìÑ [italic magenta]{PLAN_FILE}[/]")
    except Exception as e:
        console.print(f"‚ùå [bold red]Error writing plan file:[/] [red]{e}[/]")

def run_exec_mode(only_one_task: bool = False):
    """
    Executes tasks from plan.md.
    1. Initializes PlanManager.
    2. Gets the next task.
    3. Invokes CodingAgent to execute the task.
    4. Updates plan.md with task status.
    """
    console.print("üöÄ [bold bright_blue]Starting Orchestrator in EXEC mode...[/]")
    if not PLAN_FILE.exists():
        console.print(f"‚ùå [bold red]Plan file[/] üìÑ [italic magenta]{PLAN_FILE}[/] [bold red]not found. Run 'plan' mode first. Exiting.[/]")
        return

    try:
        with open(PLAN_FILE, 'r', encoding='utf-8') as f:
            full_plan_content = f.read()
    except Exception as e:
        console.print(f"‚ùå [bold red]Error reading full plan file[/] üìÑ [italic magenta]{PLAN_FILE}[/]: [red]{e}[/]")
        console.print("‚ùå [bold red]Cannot proceed without the full plan for context. Exiting exec mode.[/]")
        return

    plan_manager = PlanManager(PLAN_FILE)
    
    api_key = os.getenv('GEMINI_API_KEY')
    if not api_key:
        console.print("‚ùå [bold red]Error: GEMINI_API_KEY environment variable not set. Coding Agent cannot operate.[/]")
        sys.exit(1)
    
    gemini_agent_instance = CodeAgent(api_key=api_key, model_name="gemini-2.5-pro-preview-05-06")
    coding_agent = CodingAgent(gemini_agent_instance, SANDBOX_DIR)

    while True:
        task = plan_manager.get_next_task()
        if not task:
            console.print("‚úÖ [bold green]All tasks completed or no actionable tasks found.[/]")
            break

        console.print(f"\nüìå [bold]Executing Task ID:[/] [cyan]{task.id}[/] - [bold]Description:[/] [magenta]{task.description}[/]")

        success, notes = coding_agent.execute_task(task, full_plan_content)

        if success:
            console.print(f"‚úÖ [bold green]Task {task.id} completed successfully.[/]")
            plan_manager.update_task_status(task.id, "done", notes)
        else:
            console.print(f"‚ùå [bold red]Task {task.id} failed:[/] [red]{notes}[/]")
            console.print("‚èπÔ∏è [bold yellow]Halting execution due to task failure. The plan file has not been updated for this task.[/]")
            break
        
        if only_one_task:
            console.print("‚è≠Ô∏è [bold yellow]--onlyone flag set: Exiting after completing one task.[/]")
            break

    console.print("üèÅ [bold bright_blue]Execution mode finished.[/]")

def run_package_mode():
    """
    Uses PackagingAgent to extract and install npm packages from the plan.md file.
    """
    console.print("üì¶ [bold bright_blue]Starting Orchestrator in PACKAGE mode...[/]")
    if not PLAN_FILE.exists():
        console.print(f"‚ùå [bold red]Plan file[/] üìÑ [italic magenta]{PLAN_FILE}[/] [bold red]not found. Run 'plan' mode first. Exiting.[/]")
        return

    try:
        with open(PLAN_FILE, 'r', encoding='utf-8') as f:
            plan_content = f.read()
    except Exception as e:
        console.print(f"‚ùå [bold red]Error reading plan file[/] üìÑ [italic magenta]{PLAN_FILE}[/]: [red]{e}[/]")
        return

    packaging_agent = PackagingAgent(output_dir=OUTPUT_DIR)
    console.print("‚ú® [bold blue]Invoking PackagingAgent to install packages...[/]")
    success = packaging_agent.install_packages_from_plan(plan_content)

    if success:
        console.print("‚úÖ [bold green]Packaging mode completed successfully.[/]")
    else:
        console.print("‚ùå [bold red]Packaging mode encountered errors during package installation.[/]")

def run_full_pipeline():
    """
    Runs plan -> package -> exec in sequence.
    """
    console.print("ü§ñ [bold bright_blue]No arguments provided. Running full pipeline: PLAN ‚Üí PACKAGE ‚Üí EXEC[/]")
    
    INPUT_DIR.mkdir(parents=True, exist_ok=True)
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    console.print(f"üìÇ [bold]Sandbox input directory:[/] [italic magenta]{INPUT_DIR.resolve()}[/]")
    console.print(f"üìÇ [bold]Sandbox output directory:[/] [italic magenta]{OUTPUT_DIR.resolve()}[/]")

    
    run_plan_mode()
    
    if not PLAN_FILE.exists() or PLAN_FILE.stat().st_size == 0:
        console.print("‚ùå [bold red]Plan file was not created or is empty. Aborting pipeline.[/]")
        return

    
    run_package_mode()
    

    
    run_exec_mode(only_one_task=False)

def main():
    
    if len(sys.argv) == 1:
        run_full_pipeline()
        return

    parser = argparse.ArgumentParser(description="Migration Agent Orchestrator")
    parser.add_argument(
        "mode",
        choices=["plan", "exec", "package"],
        help="The mode to run the orchestrator in: 'plan' to generate migration plan, 'exec' to execute tasks, 'package' to install npm dependencies."
    )
    parser.add_argument(
        '--onlyone',
        action='store_true',
        help='In exec mode, run only the first actionable todo task and then exit.'
    )
    args = parser.parse_args()

    if args.onlyone and args.mode != "exec":
        console.print("‚ö†Ô∏è [bold yellow]Warning:[/] [yellow]--onlyone flag is only applicable in 'exec' mode. Ignoring.[/]")

    
    INPUT_DIR.mkdir(parents=True, exist_ok=True)
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    console.print(f"üìÇ [bold]Sandbox input directory:[/] [italic magenta]{INPUT_DIR.resolve()}[/]")
    console.print(f"üìÇ [bold]Sandbox output directory:[/] [italic magenta]{OUTPUT_DIR.resolve()}[/]")

    if args.mode == "plan":
        run_plan_mode()
    elif args.mode == "exec":
        run_exec_mode(args.onlyone)
    elif args.mode == "package":
        run_package_mode()

if __name__ == "__main__":
    main()
